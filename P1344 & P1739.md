# P1344  Negative Cycle
有向图判断是否存在负环，若有，输出负环


类似于最短路算法，设置 $dis$ 数组。考虑每一轮扫描图中的所有边并对 $dis$ 数组进行更新（松弛操作）。对于一个负环，可以无限更新下去。而若图中不存在负环，由于图中点数为 $n$，则经过 $n-1$ 轮更新一定能确定两点间的最短路径（这是因为两点点的最短路径上至多有 $n-1$ 条边，而每次至少能多确定一条边）。故我们考虑更新 $n$ 轮，若第 $n$ 轮仍有某点的 $dis$ 值被更新，则一定存在负环，否则不存在。

另外，在最短路算法中，我们将初始 $dis$ 数组设置为无穷大，对于边 $(x, y, z)$， 当 $dis_y\lt dis_x + z$ 时更新$dis_y$。若我们将 $dis$ 数组初始化为 $0$， 则当且仅当出现负边时才会更新 $dis$ 的值，可以提高效率。代码如下：

```c++
int last_upd = -1, node = -1;
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
		if (dis[y[j]] > dis[x[j]] + z[j]) {
			dis[y[j]] = dis[x[j]] + z[j];
			pre[y[j]] = x[j]; // 记录路径
			last_upd = i;
			node = y[j]; // 记录路径起始点
		}
	}
}
```

在更新 $dis$ 数组时记录路径，最后通过记录的路径还原出负环即可。

上述就是Bellmen-Ford算法判负环，其实就是一种最短路算法，所以还可以可以考虑SPFA等等。

# P1739 Bracket Query
题意：定义合法的括号序列，给出 $q$ 个区间 $[l,r]$ 中左括号数减右括号数的值，要求判断是否存在满足所有限制条件的合法的括号序列，若存在，给出一个可能的序列。

想不到吧这竟然是一道图论题 :D

记空串为节点 $0$，$dis_0=0$，长度为 $i$ 的前缀串用节点 $i$ 表示，根据给出的 $q$ 个限制连边，即边 $(u,v,w)$ 表示从 $u$ 走到 $v$ 左括号与右括号之差增大了 $w$。所以对每个输入 $(l,r,c)$，我们连边 $(l-1,r,c)$ 和 $(r,l-1,-c)$.

考虑维护限制与限制之间的关系。具体而言，若已知 $a$ 与 $b$ 之间有限制，$b$ 与 $c$ 之间有限制，那么 $a$ 与 $c$ 之间的限制应当已经确定了。此时对 $a$ 与 $c$ 之间的限制不需要连边，判断是否符合即可。这样做也不会连出环，故可以考虑用并查集维护上述关系。特别地，节点 $n$ 与节点 $0$ 存在天然的限制关系。

考虑节点之间状态的转移，从 $i-1$ 走到 $i$ 对应字符串中第 $i$ 位是左括号或右括号，所以我们连边 $(i-1,i,1)$ 和 $(i,i-1,1)$ 分别对应第 $i$ 位是左括号和右括号的情况。

再将每个点与节点 $0$ 连边 $(i,0,0)$.

合法的括号序列<br> $\iff$ 每个前缀串中，左括号数不小于右括号数<br> $\iff$ 从 $0$ 节点走到任意节点 $i$ 得到的路径长度 $dis_i\geq 0$ <br> $\iff$ 环 $0\to 1\to\dots\to i\to 0$ 不是负环。

现在我们的图中仅有两种环，一种是上面那种非负的环，另一种应该是边权和为 $0$ 的环，否则即为无解。于是我们用 Bellmen-Ford 判一下负环（因为由前所述的连边法则可以知道，对于第二种环，正环和负环是等价的，因为对每一个正环，一定有一个恰好与它反向的负环），同时更新好 $dis$ 数组。

最后我们就得到满足条件的一张图，$dis_i-dis_{i-1}$ 应该为 $1$ 或 $-1$，分别对应第 $i$ 位是左括号或右括号。据此写出括号序列即可。